var __assign =
	(this && this.__assign) ||
	function () {
		__assign =
			Object.assign ||
			function (t) {
				for (var s, i = 1, n = arguments.length; i < n; i++) {
					s = arguments[i]
					for (var p in s)
						if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
				}
				return t
			}
		return __assign.apply(this, arguments)
	}
// Imports
import { resolve } from 'path'
import matchRange from 'version-range'
import { errtion } from './util.js'
import { versions as processVersions } from 'process'
import { readFileSync } from 'fs'
/**
 * Load the {@link Edition} with the loader.
 * @returns The result of the loaded edition.
 * @throws If failed to load, an error is thrown with the reason.
 */
export function loadEdition(edition, opts) {
	var entry = resolve(
		opts.cwd || '',
		edition.directory,
		opts.entry || edition.entry || ''
	)
	if (opts.loader == null) {
		throw errtion({
			message:
				'Could not load the edition [' +
				edition.description +
				'] as no loader was specified. This is probably due to a testing misconfiguration.',
			code: 'editions-autoloader-loader-missing',
			level: 'fatal',
		})
	}
	try {
		return opts.loader.call(edition, entry)
	} catch (loadError) {
		// Note the error with more details
		throw errtion(
			{
				message:
					'Failed to load the entry [' +
					entry +
					'] of edition [' +
					edition.description +
					'].',
				code: 'editions-autoloader-loader-failed',
				level: 'fatal',
			},
			loadError
		)
	}
}
/**
 * Verify the {@link Edition} has all the required properties.
 * @returns if valid
 * @throws if invalid
 */
export function isValidEdition(edition) {
	if (
		!edition.description ||
		!edition.directory ||
		!edition.entry ||
		edition.engines == null
	) {
		throw errtion({
			message:
				'An edition must have its [description, directory, entry, engines] fields defined, yet all this edition defined were [' +
				Object.keys(edition).join(', ') +
				']',
			code: 'editions-autoloader-invalid-edition',
			level: 'fatal',
		})
	}
	// valid
	return true
}
/**
 * Is this {@link Edition} suitable for these versions?
 * @returns if compatible
 * @throws if incompatible
 */
export function isCompatibleVersion(range, version, opts) {
	// prepare
	var broadenRange = opts.broadenRange
	if (!version)
		throw errtion({
			message:
				'No version was specified to compare the range [' + range + '] against',
			code: 'editions-autoloader-engine-version-missing',
			level: 'fatal',
		})
	if (range == null || range === '')
		throw errtion({
			message:
				'The edition range was not specified, so unable to compare against the version [' +
				version +
				']',
			code: 'editions-autoloader-engine-range-missing',
		})
	if (range === false)
		throw errtion({
			message: 'The edition range does not support this engine',
			code: 'editions-autoloader-engine-unsupported',
		})
	if (range === true) return true
	// semver compare
	if (matchRange(version, range)) {
		return true
	} else if (broadenRange === true) {
		// broaden range
		var index = range.indexOf('||')
		if (index !== -1) {
			var broadenedRange = range.substr(index)
			// broadened range attempt
			if (matchRange(version, broadenedRange)) return true
			// fail broadened range
			throw errtion({
				message:
					'The edition range [' +
					range +
					'] does not support this engine version [' +
					version +
					'], even when broadened to [' +
					broadenedRange +
					']',
				code: 'editions-autoloader-engine-incompatible-broadened',
			})
		}
		// give up
		throw errtion({
			message:
				'The edition range [' +
				range +
				'] does not support this engine version [' +
				version +
				'] and could not be broadened',
			code: 'editions-autoloader-engine-incompatible-nobroad',
		})
	} else {
		// give up
		throw errtion({
			message:
				'The edition range [' +
				range +
				'] does not support this engine version [' +
				version +
				']',
			code: 'editions-autoloader-engine-incompatible-original',
		})
	}
	// return never
}
/**
 * Checks that the provided engines are compatible against the provided versions.
 * @returns if compatible
 * @throws if incompatible
 */
export function isCompatibleEngines(engines, opts) {
	// PRepare
	var versions = opts.versions
	// Check engines exist
	if (!engines) {
		throw errtion({
			message: 'The edition had no engines to compare against the environment',
			code: 'editions-autoloader-invalid-engines',
		})
	}
	// Check versions exist
	if (!versions) {
		throw errtion({
			message: 'No versions were supplied to compare the engines against',
			code: 'editions-autoloader-invalid-versions',
			level: 'fatal',
		})
	}
	// Check each version
	var compatible = false
	for (var key in engines) {
		if (engines.hasOwnProperty(key)) {
			// deno's std/node/process provides both `deno` and `node` keys
			// so we don't won't to compare node when it is actually deno
			if (key === 'node' && versions.deno) continue
			// prepare
			var engine = engines[key]
			var version = versions[key]
			// skip for engines this edition does not care about
			if (version == null) continue
			// check compatibility against all the provided engines it does care about
			try {
				isCompatibleVersion(engine, version, opts)
				compatible = true
				// if any incompatibility, it is thrown, so no need to set to false
			} catch (rangeError) {
				throw errtion(
					{
						message:
							'The engine [' +
							key +
							'] range of [' +
							engine +
							'] was not compatible against version [' +
							version +
							'].',
						code: 'editions-autoloader-engine-error',
					},
					rangeError
				)
			}
		}
	}
	// if there were no matching engines, then throw
	if (!compatible) {
		throw errtion({
			message:
				'There were no supported engines in which this environment provides.',
			code: 'editions-autoloader-engine-mismatch',
		})
	}
	// valid
	return true
}
/**
 * Checks thaat the {@link Edition} is compatible against the provided versions.
 * @returns if compatible
 * @throws if incompatible
 */
export function isCompatibleEdition(edition, opts) {
	try {
		return isCompatibleEngines(edition.engines, opts)
	} catch (compatibleError) {
		throw errtion(
			{
				message:
					'The edition [' +
					edition.description +
					'] is not compatible with this environment.',
				code: 'editions-autoloader-edition-incompatible',
			},
			compatibleError
		)
	}
}
/**
 * Determine which edition should be loaded.
 * If {@link VersionOptions.broadenRange} is unspecified (the default behaviour), then we attempt to determine a suitable edition without broadening the range, and if that fails, then we try again with the range broadened.
 * @returns any suitable editions
 * @throws if no suitable editions
 */
export function determineEdition(editions, opts) {
	// Prepare
	var broadenRange = opts.broadenRange
	// Check
	if (!editions || editions.length === 0) {
		throw errtion({
			message: 'No editions were specified.',
			code: 'editions-autoloader-editions-missing',
		})
	}
	// Cycle through the editions determing the above
	var failure = null
	for (var i = 0; i < editions.length; ++i) {
		var edition = editions[i]
		try {
			isValidEdition(edition)
			isCompatibleEdition(edition, opts)
			// return the edition if it is successful
			return edition
		} catch (error) {
			if (error.level === 'fatal') {
				throw errtion(
					{
						message: 'Unable to determine a suitable edition due to failure.',
						code: 'editions-autoloader-fatal',
						level: 'fatal',
					},
					error
				)
			} else if (failure) {
				failure = errtion(error, failure)
			} else {
				failure = error
			}
		}
	}
	//
	if (failure) {
		// try broadened
		if (broadenRange == null)
			try {
				return determineEdition(
					editions,
					__assign(__assign({}, opts), { broadenRange: true })
				)
			} catch (error) {
				throw errtion(
					{
						message:
							'Unable to determine a suitable edition, even after broadening.',
						code: 'editions-autoloader-none-broadened',
					},
					error
				)
			}
		// fail
		throw errtion(
			{
				message:
					'Unable to determine a suitable edition, as none were suitable.',
				code: 'editions-autoloader-none-suitable',
			},
			failure
		)
	}
	// this should never reach here
	throw errtion({
		message:
			'Unable to determine a suitable edition, as an unexpected pathway occured.',
		code: 'editions-autoloader-never',
	})
}
/**
 * Determine which edition should be loaded, and attempt to load it.
 * @returns the loaded result of the suitable edition
 * @throws if no suitable editions, or the edition failed to load
 */
export function solicitEdition(editions, opts) {
	var edition = determineEdition(editions, opts)
	return loadEdition(edition, opts)
}
/**
 * Cycle through the editions for a package, determine the compatible edition, and load it.
 * @returns the loaded result of the suitable edition
 * @throws if no suitable editions, or if the edition failed to load
 */
export function requirePackage(cwd, loader, entry) {
	// load editions
	var packagePath = resolve(cwd || '', 'package.json')
	var editions = JSON.parse(readFileSync(packagePath, 'utf8')).editions
	// load edition
	return solicitEdition(editions, {
		versions: processVersions,
		cwd: cwd,
		loader: loader,
		entry: entry,
	})
}
