declare type PotentialError = Errlop | Error | ErrorCodeHolder | string
interface ErrorCodeHolder {
	exitCode?: string | number
	errno?: string | number
	code?: string | number
}
export default class Errlop extends Error {
	/** Duck typing as node 4 and intanceof does not work for error extensions */
	klass: typeof Errlop
	/**
	 * The parent error if it was provided.
	 * If a parent was provided, then use that, otherwise use the input's parent, if it exists.
	 */
	parent?: Errlop | Error | null
	/** An array of all the ancestors. From parent, to grand parent, and so on. */
	ancestors: Array<Errlop | Error>
	/**
	 * A numeric code to use for the exit status if desired by the consumer.
	 * It cycles through [input, this, ...ancestors] until it finds the first [exitCode, errno, code] that is valid.
	 */
	exitCode?: string | number
	/**
	 * The stack for our instance alone, without any parents.
	 * If the input contained a stack, then use that.
	 */
	orphanStack: string
	/**
	 * The stack which now contains the accumalated stacks of its ancestors.
	 * This is used instead of an alias like `fullStack` or the like, to ensure existing code that uses `err.stack` doesn't need to be changed to remain functional.
	 */
	stack: string
	/**
	 * Syntatic sugar for Errlop class creation.
	 * Enables `Errlop.create(...args)` to achieve `new Errlop(...args)`
	 */
	static create(input: PotentialError, parent?: Errlop | Error | null): Errlop
	/**
	 * Create an instance of an error, using a message, as well as an optional parent.
	 * If the parent is provided, then the `fullStack` property will include its stack too
	 */
	constructor(input: PotentialError, parent?: Errlop | Error | null)
	/** Check whether or not the value is an Errlop instance */
	static isErrlop(value: any): boolean
	/** Ensure that the value is an Errlop instance */
	static ensure(value: any): Errlop
}
export {}
//# sourceMappingURL=index.d.ts.map
